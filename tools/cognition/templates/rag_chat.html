<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RAG Server Chat</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/markdown-it/13.0.1/markdown-it.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.3.0/mermaid.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"
    />

    <style>
      :root {
        --primary: #ff00a0;
        --primary-hover: #e4008e;
        --text-primary: #ffffff;
        --text-secondary: #e5e7eb;
        --text-muted: #a0a0a0;
        --bg-main: #121214;
        --bg-secondary: #1c1c1f;
        --border-color: #2a2a2d;
        --font-family: "JetBrains Mono", monospace;
        --sidebar-width: 300px;
        --sidebar-width-collapsed: 60px;
        --slider-width: 40px;
        --slider-height: calc(var(--slider-width) * 0.5);
        --surrealist-gradient: linear-gradient(
          135deg,
          var(--primary) 0%,
          #9600ff 100%
        );
      }

      @font-face {
        font-family: "JetBrains Mono";
        src: url("https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap");
      }

      html,
      body {
        background-color: var(--bg-main);
        color: var(--text-primary);
        font-family: var(--font-family);
        margin: 0;
        padding: 0;
      }

      /* Wrap main content to avoid overlapping the sidebar */
      #main-content {
        width: 800px;
        margin: 20px auto;
        padding: 20px;
        padding-bottom: 80px;
        transition: margin-right 0.3s ease;
        position: relative;
        left: calc(-1 * (var(--sidebar-width) + 20px) / 2);
      }

      #main-content.sidebar-collapsed {
        left: calc(-1 * (var(--sidebar-width-collapsed) + 20px) / 2);
      }

      /* Sidebar styling */
      #sidebar {
        position: fixed;
        top: 0;
        right: 0;
        width: var(--sidebar-width);
        height: 100vh;
        background-color: rgba(25, 25, 29, 0.95);
        backdrop-filter: blur(10px);
        border-left: 1px solid var(--border-color);
        padding: 1.5rem;
        padding-top: 1rem;
        box-sizing: border-box;
        overflow-x: hidden;
        overflow-y: auto;
        transition: width 0.3s ease;
        z-index: 1000;
      }

      .resizer {
        width: 5px;
        cursor: ew-resize;
        background-color: var(--border-color);
        position: absolute;
        left: 0;
        /* Adjust if your sidebar is on the right */
        top: 0;
        height: 100%;
        z-index: 1001;
      }

      details {
        background: var(--surrealist-gradient);
        border-radius: 5px;
        padding: 10px;
        margin-bottom: 10px;
        font-family: Arial, sans-serif;
      }

      details[open] {
        background: #121214;
      }

      summary {
        font-weight: bold;
        cursor: pointer;
      }

      .switch {
        position: relative;
        display: inline-block;
        min-width: var(--slider-width);
        width: var(--slider-width);
        height: var(--slider-height);
        margin-bottom: 0px !important;
      }

      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }

      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: 0.4s;
        border-radius: 24px;
      }

      .slider:before {
        position: absolute;
        content: "";
        height: calc(var(--slider-height) * 0.8) !important;
        width: calc(var(--slider-height) * 0.8);
        /* Adjust left and bottom if the inner circle gets offset */
        left: 4px;
        bottom: 2px;
        background-color: white;
        transition: 0.4s;
        border-radius: 50%;
      }

      input:checked + .slider {
        background-color: var(--primary);
      }

      input:checked + .slider:before {
        transform: translateX(calc(var(--slider-height) * 0.8));
      }

      #sidebar.collapsed {
        width: var(--sidebar-width-collapsed);
        padding: 1rem 0.5rem;
        display: flex;
        flex-direction: column;
        align-items: center;
        overflow-x: visible;
        /* Allow tooltips to overflow */
      }

      .available-header {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
      }

      .delete-all {
        margin-top: 0px !important;
        font-size: 0.7em !important;
      }

      .delete-all:hover {
        color: var(--primary-hover) !important;
        cursor: pointer;
        user-select: none;
      }

      .sidebar-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 1rem;
        padding-bottom: 8px;
        border-bottom: 1px solid var(--border-color);
      }

      #sidebar.collapsed .sidebar-header {
        justify-content: center;
        padding-bottom: 8px;
        border-bottom: 1px solid var(--border-color);
        width: 100%;
        margin: 0 auto;
      }

      #sidebar.collapsed .sidebar-header #sidebar-toggle {
        width: 100%;
      }

      #sidebar.collapsed details,
      #sidebar.collapsed summary,
      #sidebar.collapsed h2,
      #sidebar.collapsed h3,
      #sidebar.collapsed h4,
      #sidebar.collapsed .tools-form,
      #sidebar.collapsed .source-form,
      #sidebar.collapsed .source-item-name,
      #sidebar.collapsed .source-item-description,
      #sidebar.collapsed .tool-item-name,
      #sidebar.collapsed .tool-item-description,
      #sidebar.collapsed .source-actions,
      #sidebar.collapsed .tool-actions {
        display: none;
      }

      #sidebar h2 {
        margin: 0;
        font-size: 1.4em;
        color: var(--text-primary);
        /* Remove border-bottom since it's moved to header */
        padding: 0;
        display: flex;
        align-items: center;
      }

      #sidebar h3 {
        font-size: 1em;
        margin: 0;
        color: var(--text-secondary);
      }

      #sidebar h4 {
        font-size: 0.9em;
        margin: 8px 0;
        color: var(--text-secondary);
      }

      .source-section-title {
        border-top: 1px solid var(--border-color);
        padding-top: 15px !important;
        margin-top: 5px !important;
      }

      .source-section,
      .tools-section {
        display: flex;
        flex-direction: column;
        gap: 15px;
      }

      /* Add border above active tools header */
      .sources-header,
      .tools-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
        border-top: 1px solid var(--border-color);
        padding-top: 15px;
        margin-top: 5px;
      }

      .section-inner-title {
        font-size: 0.8em !important;
      }

      .sources-list,
      .tools-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .source-item,
      .tool-item {
        margin-top: 10px;
        display: flex;
        flex-direction: row;
        background: var(--bg-main);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        position: relative;
        /* For tooltip positioning */
      }

      .source-item.active,
      .tool-item.active {
        border-color: var(--primary);
        background: linear-gradient(
          135deg,
          rgba(255, 0, 160, 0.2) 0%,
          rgba(150, 0, 255, 0.2) 100%
        );
      }

      /* Add tooltip styles */
      .source-item::after,
      .tool-item::after {
        content: attr(data-tooltip);
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        padding: 4px 8px;
        color: var(--text-secondary);
        font-size: 0.8em;
        white-space: nowrap;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.2s, visibility 0.2s;
        z-index: 1000;
        pointer-events: none;
      }

      .source-item:hover::after,
      .tool-item:hover::after {
        opacity: 1;
        visibility: visible;
      }

      /* Add text selection color */
      ::selection {
        background: rgba(255, 0, 160, 0.3);
        color: var(--text-primary);
      }

      ::-moz-selection {
        background: rgba(255, 0, 160, 0.3);
        color: var(--text-primary);
      }

      .source-item-header,
      .tool-item-header {
        display: flex;
        width: 100%;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
      }

      .source-item-name,
      .tool-item-name {
        flex: 1;
        font-size: 0.9em;
        font-weight: bold;
        color: var(--text-primary);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .upload-icon,
      .source-icon,
      .tool-icon {
        color: var(--text-muted);
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .tool-item-actor {
        font-size: 0.9em;
        color: var(--text-muted);
      }

      .source-item-description,
      .tool-item-description {
        font-size: 0.9em;
        color: var(--text-secondary);
        margin-top: 5px;
      }

      .loading-indicator {
        width: 100% !important;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      #loading-indicator {
        font-size: 14px;
        color: var(--primary);
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 5px;
      }

      #loading-indicator i {
        font-size: 18px;
      }

      .source-form,
      .tools-form {
        background: var(--bg-main);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: 12px;
      }

      .tools-form.hidden {
        display: none;
      }

      .form-group {
        margin-bottom: 12px;
      }

      .form-group input,
      .form-group textarea {
        width: 100%;
        padding: 6px 8px;
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        color: var(--text-primary);
        font-family: var(--font-family);
        font-size: 0.9em;
      }

      /* Add focus styles to match chat input */
      .form-group input:focus,
      .form-group textarea:focus {
        border-color: var(--primary);
        outline: none;
        box-shadow: 0 0 0 2px rgba(255, 0, 160, 0.2);
      }

      .form-info {
        display: flex;
        flex-direction: row;
        width: 100%;
        justify-content: space-between;
      }

      .form-actions {
        display: flex;
        gap: 8px;
        justify-content: end;
      }

      .form-actions .action-button {
        padding: 6px 12px;
        font-size: 0.9em;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .saved-sources-section,
      .saved-tools-section {
        margin-top: 15px;
        padding-top: 15px;
        border-top: 1px solid var(--border-color);
      }

      .source-actions,
      .tool-actions {
        display: flex;
        gap: 4px;
      }

      .source-action-btn,
      .tool-action-btn {
        background: none;
        border: none;
        color: var(--text-muted);
        cursor: pointer;
        padding: 4px;
        transition: color 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 24px;
        height: 24px;
      }

      #add-tool-btn {
        padding: 4px 8px;
        font-size: 0.9em;
      }

      #sidebar-toggle {
        position: static;
        background: none;
        border: none;
        color: var(--text-primary);
        cursor: pointer;
        padding: 0.5rem;
        border-radius: 0.375rem;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 32px;
        height: 32px;
      }

      #sidebar-toggle:hover {
        background-color: rgba(255, 255, 255, 0.1);
        box-shadow: var(--surrealist-glow);
        color: var(--primary);
      }

      #sidebar-toggle svg {
        width: 16px;
        height: 16px;
        transition: transform var(--transition-speed);
        transform: rotate(180deg);
        /* Start rotated */
      }

      #sidebar.collapsed #sidebar-toggle svg {
        transform: rotate(0deg);
        /* Return to original position when collapsed */
      }

      #input-container {
        position: fixed;
        bottom: 0;
        width: 820px;
        left: 50%;
        transform: translateX(-50%);
        margin-left: calc(-1 * (var(--sidebar-width) + 20px) / 2);
        padding: 20px;
        background-color: var(--bg-secondary);
        box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.15);
        box-sizing: border-box;
        border-radius: 10px 10px 0 0;
        display: flex;
        flex-direction: column;
        gap: 12px;
        transition: margin-left 0.3s ease;
        z-index: 999;
        cursor: text;
      }

      #input-container * {
        cursor: inherit;
      }

      #query-input {
        width: 100%;
        margin: 0;
        padding: 12px;
        box-sizing: border-box;
        border-radius: 8px;
        background-color: transparent;
        color: var(--text-primary);
        border: none;
        resize: none;
        min-height: 50px;
        max-height: 200px;
        overflow-y: auto;
        font-family: var(--font-family);
        font-size: 1em;
        line-height: 1.5;
        cursor: text;
      }

      #query-input:focus {
        outline: none;
      }

      .utilities-container button,
      .action-button,
      .send-button,
      #stop-button {
        cursor: pointer !important;
      }

      .send-button:disabled {
        cursor: not-allowed !important;
      }

      #input-container.sidebar-collapsed {
        margin-left: calc(-1 * (var(--sidebar-width-collapsed) + 20px) / 2);
      }

      .input-wrapper {
        position: relative;
        width: 100%;
      }

      .utilities-container {
        display: flex;
        gap: 10px;
        justify-content: space-between;
        align-items: center;
      }

      .utilities-left {
        display: flex;
        gap: 10px;
        align-items: center;
      }

      .utilities-right {
        position: relative;
        width: 48px;
        /* Fixed width for both send and stop buttons */
        height: 48px;
        /* Fixed height for both send and stop buttons */
      }

      .send-button,
      #stop-button {
        position: absolute;
        top: 0;
        right: 0;
        width: 48px;
        height: 48px;
        border: none;
        border-radius: 50%;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: var(--font-family);
      }

      .send-button {
        background: var(--surrealist-gradient);
        color: var(--text-primary);
        cursor: pointer;
      }

      .send-button:disabled {
        background: var(--bg-secondary);
        cursor: not-allowed;
        opacity: 0.5;
      }

      .send-button:hover:not(:disabled) {
        opacity: 0.9;
      }

      #stop-button {
        background: linear-gradient(135deg, #ff4444 0%, #ff6b6b 100%);
        color: var(--text-primary);
        display: none;
        /* Hidden by default */
        cursor: pointer;
      }

      .send-button i,
      #stop-button i {
        font-size: 1.2em;
      }

      #chat-container {
        margin-bottom: 80px;
        display: flex;
        flex-direction: column;
        position: relative;
        z-index: 1;
      }

      .message {
        margin-bottom: 15px;
        padding: 12px;
        border-radius: 12px;
        max-width: 85%;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        position: relative;
      }

      .user-message {
        background: var(--surrealist-gradient);
        align-self: flex-end;
        margin-left: auto;
        color: var(--text-primary);
        position: relative;
        /* For positioning the edit icon */
        position: relative;
        /* For positioning the edit icon */
      }

      .user-message::before {
        content: "";
        position: absolute;
        left: -35px;
        top: 0;
        bottom: 0;
        width: 35px;
        pointer-events: auto;
      }

      .assistant-message {
        background-color: var(--bg-secondary);
        align-self: flex-start;
        border: 1px solid var(--border-color);
        color: var(--text-primary);
      }

      .system-message {
        background-color: #2a2a2d;
        align-self: flex-start;
        border: 1px solid var(--border-color);
        color: var(--text-secondary);
      }

      .tool-message {
        background-color: #1a1a1d;
        align-self: flex-start;
        font-family: var(--font-family);
        position: relative;
        border: 1px solid var(--border-color);
        color: var(--text-secondary);
      }

      .edit-icon {
        position: absolute;
        top: 50%;
        left: -35px;
        transform: translateY(-50%);
        background: var(--bg-secondary);
        color: var(--text-primary);
        padding: 5px;
        border-radius: 50%;
        cursor: pointer;
        display: none;
        font-size: 1em;
        z-index: 100;
      }

      .user-message:hover .edit-icon,
      .edit-icon:hover {
        display: block;
      }

      .context-toggle {
        font-size: 0.8em;
        color: var(--text-muted);
        cursor: pointer;
        margin-top: 10px;
        padding: 5px 10px;
        background-color: var(--bg-secondary);
        border-radius: 4px;
        display: inline-block;
        user-select: none;
        transition: background-color 0.2s, color 0.2s;
        border: 1px solid var(--border-color);
      }

      .context-toggle:hover {
        background: var(--surrealist-gradient);
        color: var(--text-primary);
      }

      .context-content {
        display: none;
        margin-top: 10px;
        padding: 12px;
        background-color: var(--bg-secondary);
        border-radius: 8px;
        border: 1px solid var(--border-color);
        color: var(--text-secondary);
      }

      .context-content .message {
        margin: 8px 0;
        padding: 10px;
        font-size: 0.9em;
        max-width: 100%;
        background-color: var(--bg-main);
      }

      .context-content .user-message {
        background: linear-gradient(
          135deg,
          rgba(255, 0, 160, 0.15) 0%,
          rgba(150, 0, 255, 0.15) 100%
        );
        border: 1px solid rgba(255, 0, 160, 0.2);
        color: var(--text-primary);
      }

      .context-content .assistant-message {
        background-color: var(--bg-main);
        border: 1px solid var(--border-color);
        color: var(--text-secondary);
      }

      .context-content .system-message {
        background-color: rgba(42, 42, 45, 0.5);
        border: 1px solid var(--border-color);
        color: var(--text-muted);
      }

      .context-content .tool-message {
        background-color: rgba(26, 26, 29, 0.8);
        border: 1px solid var(--border-color);
        color: var(--text-secondary);
      }

      .context-content .message strong {
        display: block;
        margin-bottom: 5px;
        color: var(--text-muted);
      }

      .source-separator {
        border-top: 1px solid var(--border-color);
        margin-top: 10px;
        padding-top: 10px;
      }

      .source,
      .uri,
      .chunk {
        margin-bottom: 5px;
      }

      .tool-toggle {
        color: var(--text-muted);
        position: absolute;
        top: 16px;
        left: 8px;
        cursor: pointer;
        width: 16px;
        height: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
        user-select: none;
        transition: background-color 0.2s, color 0.2s;
      }

      .tool-content {
        margin-left: 28px;
        display: none;
      }

      .tool-header {
        margin-left: 28px;
        padding: 4px 0;
        color: var(--text-muted);
      }

      .tool-function {
        margin-bottom: 8px;
        color: var(--text-secondary);
      }

      .tool-details pre {
        background-color: rgba(255, 255, 255, 0.05);
        padding: 10px;
        border-radius: 6px;
        margin: 6px 0 14px 0;
        overflow-x: auto;
        border: 1px solid var(--border-color);
      }

      .tool-details code {
        font-size: 0.9em;
        color: #ff80cc;
      }

      .tool-toggle:hover {
        background: var(--surrealist-gradient);
        color: var(--text-primary);
      }

      .message,
      .context-toggle,
      .tool-toggle,
      #query-input {
        transition: background-color 0.2s, color 0.2s, border-color 0.2s,
          box-shadow 0.2s;
      }

      /* Scrollbar styling */
      ::-webkit-scrollbar {
        width: 8px;
      }

      ::-webkit-scrollbar-track {
        background: var(--bg-secondary);
      }

      ::-webkit-scrollbar-thumb {
        background: var(--primary);
        border-radius: 4px;
      }

      ::-webkit-scrollbar-thumb:hover {
        background: var(--primary-hover);
      }

      .action-button {
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        color: var(--text-primary);
        padding: 10px 15px;
        border-radius: 5px;
        cursor: pointer;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
      }

      .action-button:not(.active):hover {
        background: var(--surrealist-gradient);
        border-color: var(--primary);
      }

      .action-button.active {
        background: var(--surrealist-gradient);
        border-color: var(--primary);
      }

      .action-button.active i {
        color: var(--text-primary);
      }

      .action-button i {
        font-size: 1.2em;
      }

      /* Remove hover styles for disabled buttons */
      .action-button[style*="cursor: not-allowed"]:hover {
        background: var(--bg-secondary) !important;
        border-color: var(--border-color) !important;
      }

      /* Override any specific button hover styles */
      #send-button:hover:not(.active),
      #think-button:hover:not(.active) {
        background: linear-gradient(
          135deg,
          rgba(255, 0, 160, 0.2) 0%,
          rgba(150, 0, 255, 0.2) 100%
        );
        border-color: var(--primary);
      }

      #send-button:hover:not(.active) i,
      #think-button:hover:not(.active) i {
        background: var(--surrealist-gradient);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      /* Thinking process styles - simplified */
      .thinking-process {
        margin-bottom: 15px;
        position: relative;
        max-width: 85%;
        align-self: flex-start;
      }

      .thinking-header {
        display: inline-flex;
        align-items: center;
        cursor: pointer;
        user-select: none;
        color: var(--text-muted);
        font-size: 0.95rem;
        width: 100%;
      }

      .thinking-header i,
      .thinking-header .thinking-text {
        background: linear-gradient(
          to right,
          var(--text-muted) 25%,
          var(--primary) 50%,
          var(--text-muted) 75%
        );
        background-size: 200% 100%;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        animation: sweepingHighlight 2s infinite linear;
        transition: all 0.2s ease;
      }

      .thinking-text.static {
        background: none;
        -webkit-text-fill-color: var(--text-muted);
        color: var(--text-muted);
      }

      @keyframes sweepingHighlight {
        0% {
          background-position: 200% 0;
        }

        100% {
          background-position: -200% 0;
        }
      }

      .thinking-content {
        margin-top: 8px;
        padding: 12px;
        display: none;
        white-space: pre-wrap;
        font-family: var(--font-family);
        font-size: 0.9em;
        color: var(--text-muted);
        background: linear-gradient(
          135deg,
          rgba(255, 0, 160, 0.05) 0%,
          rgba(150, 0, 255, 0.05) 100%
        );
        border: 1px solid rgba(255, 0, 160, 0.2);
        border-radius: 8px;
        line-height: 1.5;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        max-width: 100%;
        overflow-wrap: break-word;
      }

      .thinking-content.visible {
        display: block;
        animation: fadeIn 0.2s ease-in-out;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }

        to {
          opacity: 1;
        }
      }

      .message a {
        color: var(--primary);
        text-decoration: none;
        transition: color 0.2s;
      }

      .message a:hover {
        color: var(--primary-hover);
        text-decoration: underline;
      }

      .error-message {
        background-color: var(--bg-main);
        border: 1px solid var(--border-color);
        color: #ff6b6b;
        align-self: flex-start;
        padding: 12px;
        border-radius: 12px;
        max-width: 85%;
        margin-bottom: 15px;
        position: relative;
      }

      .error-toggle {
        color: var(--text-muted);
        position: absolute;
        top: 16px;
        left: 8px;
        cursor: pointer;
        width: 16px;
        height: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: rgba(255, 0, 0, 0.1);
        border-radius: 4px;
        user-select: none;
        transition: background-color 0.2s, color 0.2s;
      }

      .error-toggle:hover {
        background: linear-gradient(
          135deg,
          rgba(255, 0, 0, 0.2) 0%,
          rgba(255, 0, 0, 0.3) 100%
        );
        color: #ff4444;
      }

      .error-header {
        margin-left: 28px;
        padding: 4px 0;
        color: #ff6b6b;
        font-weight: bold;
      }

      .error-content {
        margin-left: 28px;
        display: none;
        padding-top: 8px;
      }

      .error-item {
        margin-bottom: 8px;
        padding: 8px;
        background-color: rgba(255, 0, 0, 0.05);
        border: 1px solid rgba(255, 0, 0, 0.1);
        border-radius: 4px;
      }

      .typing-indicator {
        display: inline-block;
        width: 8px;
        height: 8px;
        background: var(--primary);
        border-radius: 50%;
        margin-left: 2px;
        margin-right: 2px;
        vertical-align: middle;
        animation: pulse 1s infinite;
        white-space: pre;
      }

      @keyframes pulse {
        0% {
          opacity: 0.4;
        }

        50% {
          opacity: 1;
        }

        100% {
          opacity: 0.4;
        }
      }

      .assistant-message p {
        display: inline;
        margin: 0;
        padding: 0;
      }

      .message pre code {
        display: block;
        padding: 1em;
        background-color: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        overflow-x: auto;
        font-size: 0.9em;
        line-height: 1.4;
        tab-size: 2;
      }

      .message .chunk > p {
        margin: 0.5em 0;
        display: block;
      }

      .message .chunk > ul,
      .message .chunk > ol {
        margin: 0.5em 0;
        padding-left: 1.5em;
      }

      #sidebar .section {
        margin-bottom: 20px;
      }

      #sidebar label {
        display: block;
        margin-bottom: 5px;
        color: var(--text-secondary);
      }

      #sidebar input {
        width: 100%;
        padding: 8px;
        box-sizing: border-box;
        border: 1px solid var(--border-color);
        border-radius: 5px;
        background-color: var(--bg-main);
        color: var(--text-primary);
      }

      /* Fix sidebar overflow issues */
      #sidebar.collapsed .source-section,
      #sidebar.collapsed .sources-list,
      #sidebar.collapsed .tools-section,
      #sidebar.collapsed .tools-list {
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      #sidebar.collapsed .source-item #sidebar.collapsed .tool-item {
        width: 32px;
        height: 32px;
        min-width: 32px;
        padding: 6px;
        margin: 4px 0;
        display: flex;
        justify-content: center;
        align-items: center;
        border-radius: 6px;
        position: relative;
      }

      #sidebar.collapsed .source-icon,
      #sidebar.collapsed .tool-icon {
        margin: 0;
        width: 14px;
        height: 14px;
      }

      #sidebar.collapsed .source-item-header,
      #sidebar.collapsed .tool-item-header {
        width: auto;
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      /* Update tooltip positioning for collapsed state */
      #sidebar.collapsed
        .source-item::after
        #sidebar.collapsed
        .tool-item::after {
        position: absolute;
        left: auto;
        right: calc(100% + 8px);
        top: 50%;
        transform: translateY(-50%);
        margin-left: 0;
        white-space: nowrap;
        z-index: 1001;
        pointer-events: none;
        padding: 4px 8px;
        color: var(--text-secondary);
        font-size: 0.8em;
      }

      /* Remove the arrow styles since we don't want them */
      #sidebar.collapsed
        .source-item::before
        #sidebar.collapsed
        .tool-item::before {
        display: none;
      }

      /* Ensure tooltips are visible */
      #sidebar.collapsed {
        overflow: visible !important;
      }

      #sidebar.collapsed .source-item #sidebar.collapsed .tool-item {
        overflow: visible !important;
        position: relative;
        /* Ensure proper tooltip positioning */
      }

      /* Add stop button styles */
      #stop-button {
        display: none;
        background: var(--bg-secondary);
        border: 1px solid #ff4444;
        color: #ff4444;
      }

      #stop-button:hover {
        background: linear-gradient(
          135deg,
          rgba(255, 68, 68, 0.2) 0%,
          rgba(255, 68, 68, 0.3) 100%
        );
      }

      #stop-button.active {
        background: linear-gradient(
          135deg,
          rgba(255, 68, 68, 0.8) 0%,
          rgba(255, 68, 68, 0.9) 100%
        );
        border-color: #ff4444;
        color: var(--text-primary);
      }

      #stop-button i {
        animation: pulse 1s infinite;
      }

      @keyframes pulse {
        0% {
          opacity: 0.4;
        }

        50% {
          opacity: 1;
        }

        100% {
          opacity: 0.4;
        }
      }
    </style>
  </head>

  <body>
    <!-- Sidebar with helper Tools section -->
    <div id="sidebar">
      <div class="sidebar-header">
        <h2>
          <i class="fa-solid fa-gear" style="margin-right: 8px"></i> Config
        </h2>
        <button id="sidebar-toggle">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M15 19l-7-7 7-7"
            />
          </svg>
        </button>
      </div>

      <details>
        <summary>
          <i class="fa-solid fa-book" style="margin-right: 8px"></i>
          Sources
        </summary>

        <br />

        <div class="section source-section">
          <div class="source-form" id="source-form">
            <h4><i class="fas fa-plus-circle"></i> Add Source</h4>
            <div class="form-group">
              <input type="text" id="source" placeholder="/global" />
            </div>
          </div>

          <div class="form-actions">
            <button
              id="new-source"
              class="new-source action-button"
              onclick="addNewSource()"
            >
              Add new source
            </button>
          </div>

          <!-- Add the hidden input for sources actors -->
          <input type="hidden" id="sources-input" value="" />

          <div id="active-sources-list" class="sources-list">
            <!-- Active sources will be listed here -->
          </div>

          <div class="saved-sources-section">
            <div class="available-header">
              <h3 class="section-inner-title" style="margin-bottom: 10px">
                <i class="fas fa-archive"></i> Available Sources
              </h3>
              <h4
                id="delete-all-sources"
                class="delete-all"
                style="margin-bottom: 10px"
              >
                <i class="fa-solid fa-trash"></i> Delete all
              </h4>
            </div>
            <div id="saved-sources-list" class="sources-list">
              <!-- Saved sources will be listed here -->
            </div>
          </div>
        </div>
      </details>

      <details>
        <summary>
          <i class="fas fa-toolbox" style="margin-right: 8px"></i> Tools
        </summary>

        <br />

        <div class="section tools-section">
          <!-- Add New Agent form moved to top -->
          <div class="tools-form" id="tool-form">
            <h4><i class="fas fa-plus-circle"></i> Add Agent</h4>
            <div class="form-group">
              <input type="text" id="tool-actor" placeholder="Agent name" />
            </div>
            <div class="form-actions">
              <button id="save-tool-btn" class="action-button">
                <i class="fas fa-save"></i> Save
              </button>
            </div>
          </div>

          <!-- Add the hidden input for tools actors -->
          <input type="hidden" id="tools-actors-input" value="" />

          <div class="saved-tools-section">
            <div class="available-header">
              <h3 class="section-inner-title" style="margin-bottom: 10px">
                <i class="fas fa-archive"></i> Available Tools
              </h3>
              <h4
                id="delete-all-tools"
                class="delete-all"
                style="margin-bottom: 10px"
              >
                <i class="fa-solid fa-trash"></i> Delete all
              </h4>
            </div>
            <div id="saved-tools-list" class="tools-list">
              <!-- Saved tools will be listed here -->
            </div>
          </div>
        </div>
      </details>

      <div id="resizer" class="resizer"></div>
    </div>

    <!-- Main Content -->
    <div id="main-content">
      <div id="chat-container"></div>
    </div>

    <!-- Input Container -->
    <div id="input-container">
      <textarea
        id="query-input"
        placeholder="How can I help you today?"
        rows="1"
      ></textarea>
      <div class="utilities-container">
        <div class="utilities-left">
          <button
            id="send-button"
            class="action-button"
            title="Chat with tools (Ctrl+Enter)"
          >
            <i class="fas fa-comments fa-wrench"></i>
          </button>
          <button
            id="think-button"
            class="action-button"
            title="Think deeply (Alt+Enter)"
          >
            <i class="fas fa-brain"></i>
          </button>
        </div>
        <div class="utilities-right">
          <button class="send-button" title="Send message" disabled>
            <i class="fas fa-arrow-up"></i>
          </button>
          <button id="stop-button" title="Stop generation">
            <i class="fas fa-stop"></i>
          </button>
        </div>
      </div>
    </div>

    <!-- Resizer logic -->

    <script>
      const resizer = document.querySelector(".resizer");
      const sidebar = document.getElementById("sidebar");
      let isResizing = false;

      resizer.addEventListener("mousedown", (e) => {
        isResizing = true;
        document.body.style.userSelect = "none"; // Prevent text selection while resizing
        document.addEventListener("mousemove", resizeSidebar);
        document.addEventListener("mouseup", stopResizing);
      });

      function resizeSidebar(e) {
        if (!isResizing) return;
        const newWidth = window.innerWidth - e.clientX;
        if (newWidth >= 280 && newWidth <= 500) {
          sidebar.style.width = `${newWidth}px`;
        }
      }

      function stopResizing() {
        if (!isResizing) return;
        isResizing = false;
        document.body.style.userSelect = "";
        document.removeEventListener("mousemove", resizeSidebar);
        document.removeEventListener("mouseup", stopResizing);

        // Force recalculation of chat container scroll
        chatContainer.scrollTop = chatContainer.scrollHeight;
      }
    </script>

    <!-- Logic for uploading and indexing file -->

    <script>
      async function uploadAndIndexSource(file, source) {
        const fileInput = document.getElementById("file-input");

        if (!file) {
          console.log("No file provided");
        }

        let directoryPath = source.path;

        if (directoryPath[0] == "/") {
          directoryPath = directoryPath.slice(1);
        }

        const metadata = {
          path: directoryPath
            ? `uploads/${directoryPath}/${file.name}`
            : `uploads/${file.name}`,
        };

        const formData = new FormData();
        formData.append("file", file);
        formData.append(
          "metadata",
          new Blob([JSON.stringify(metadata)], {
            type: "application/json",
          })
        );

        try {
          const uploadResponse = await fetch(`${RAG_ENDPOINT}/upload`, {
            method: "POST",
            body: formData,
          });

          if (uploadResponse.ok) {
            const result = await uploadResponse.json();

            const indexQuery = {
              globs: result.paths,
              source: directoryPath ? `/${directoryPath}` : undefined,
              chunk_capacity: {
                start: 500,
                end: 2000,
              },
              chunk_overlap: 200,
            };

            const response = await fetch(`${RAG_ENDPOINT}/index`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify(indexQuery),
            });

            const jsonResponse = await response.json();
          } else {
            console.error("❌ Upload failed:", await uploadResponse.text());
          }
        } catch (error) {
          console.error("⚠️ Error during upload:", error);
        } finally {
          deleteFromLocalSources(source);
          await fetchAvailableSources();
          loadSavedSources();

          fileInput.value = "";
        }
      }
    </script>

    <!-- General Logic  -->

    <script>
      // Remove any trailing slashes from the endpoint
      const RAG_ENDPOINT = window.location.origin;

      let isThinkingActive = false;
      let thinkingDiv = null;
      let thinkingContentDiv = null;
      let assistantTextBuffer = ""; // store user-visible assistant text
      let latestContext = null; // store context from the most recent chunk
      let contextSet = false; // track if we've appended the context yet
      let toolsEnabled = localStorage.getItem("toolsEnabled") === "true";
      let sourcesEnabled = localStorage.getItem("sourcesEnabled") === "true";
      let thinkEnabled = localStorage.getItem("thinkEnabled") === "true";
      let sidebarVisible = localStorage.getItem("sidebarVisible") === "true";
      let currentController = null; // Store the AbortController for the current request
      let isGenerating = false; // Track if we're currently generating a response

      const md = window.markdownit({ breaks: true });
      const chatContainer = document.getElementById("chat-container");
      const queryInput = document.getElementById("query-input");
      const stopButton = document.getElementById("stop-button");
      let messageHistory = [];
      let thinkingStartTime = null;

      mermaid.initialize({ startOnLoad: true });

      (async () => {
        await fetchAvailableSources();
      })();

      // Custom renderer for code fences (handles mermaid code blocks)
      md.renderer.rules.fence = function (tokens, idx) {
        const token = tokens[idx];
        const code = token.content.trim();
        if (token.info.trim() === "mermaid") {
          return '<div class="mermaid">' + code + "</div>";
        }
        return "<pre><code>" + md.utils.escapeHtml(code) + "</code></pre>";
      };

      // Updated helper to process a base64 image
      function processBase64Image(base64String, type = "jpeg") {
        base64String = base64String.trim();
        if (base64String.startsWith("data:image")) {
          return base64String;
        }
        try {
          atob(base64String); // verify Base64
          return `data:image/${type};base64,${base64String}`;
        } catch (e) {
          console.error("Invalid base64 string:", e);
          return null;
        }
      }

      // New helper: process message content (for both system and non-system messages)
      function processMessageContent(content, images = []) {
        let processedContent = "";
        let normalLines = [];
        let imageIndex = 0;

        // Flush accumulated normal text
        function flushNormalLines() {
          if (normalLines.length) {
            const joined = normalLines.join("\n").trim();
            if (joined) {
              try {
                // Try to detect JSON and pretty-print it
                const jsonObj = JSON.parse(joined);
                processedContent += `<pre><code>${JSON.stringify(
                  jsonObj,
                  null,
                  2
                )}</code></pre>`;
                console.log("Detected JSON content and formatted as code.");
              } catch (e) {
                // Not valid JSON; render as Markdown
                processedContent += md.render(joined);
              }
            }
            normalLines = [];
          }
        }

        // Process each line for markers
        const lines = content.split("\n");
        lines.forEach((line) => {
          const trimmedLine = line.trim();
          if (trimmedLine.startsWith("[URI:")) {
            flushNormalLines();
            let uri = trimmedLine.slice(5, -1).trim();
            processedContent += `<div class="uri">URI: ${uri}</div>`;
          } else if (trimmedLine.startsWith("Source:")) {
            flushNormalLines();
            let source = trimmedLine.slice(7).trim();
            processedContent += `<div class="source">Source: ${source}</div>`;
          } else if (trimmedLine.startsWith("[IMAGE:")) {
            flushNormalLines();
            let imageType = trimmedLine.slice(7, -1).trim();
            if (images && imageIndex < images.length) {
              let imageUrl = processBase64Image(images[imageIndex], imageType);
              if (imageUrl) {
                processedContent += `<div class="context-image"><img src="${imageUrl}" style="max-width: 100%; margin: 10px 0;"></div>`;
              }
              imageIndex++;
            } else {
              normalLines.push(line);
            }
          } else {
            normalLines.push(line);
          }
        });

        flushNormalLines();
        return processedContent;
      }

      // Replace the existing createContextSection with this updated version
      function createContextSection(context) {
        console.group("createContextSection");
        console.log("Input context:", context);

        if (!context?.length) {
          console.log("No context provided, returning empty string");
          console.groupEnd();
          return "";
        }

        let regularMessages = "";
        let systemMessage = "";
        let lastUserMessage = "";

        // Find the index of the last user message
        const lastUserIndex = [...context]
          .reverse()
          .findIndex((msg) => msg.role === "user");
        const lastMessageIndex =
          lastUserIndex !== -1 ? context.length - 1 - lastUserIndex : -1;
        console.log("Last user message index:", lastMessageIndex);

        // Process non-system messages (except the last user message)
        console.group("Processing regular messages");
        context.forEach((msg, index) => {
          if (msg.role !== "system" && index !== lastMessageIndex) {
            console.group(`Message ${index} (${msg.role})`);
            const roleClass = msg.role + "-message";
            const processedContent = processMessageContent(
              msg.content || "",
              msg.images || []
            );
            regularMessages += `
                        <div class="message ${roleClass}">
                          <div class="chunk">${processedContent}</div>
                        </div>
                      `;
            console.groupEnd();
          }
        });
        console.groupEnd();

        // Process system messages
        console.group("Processing system messages");
        context.forEach((msg, index) => {
          if (msg.role === "system") {
            console.group(`System message ${index}`);
            const roleClass = msg.role + "-message";
            let systemContent = msg.content.replace(
              /^\s*#{1,6}\s*ADDITIONAL CONTEXT:/im,
              "ADDITIONAL CONTEXT:"
            );
            const processedContent = processMessageContent(
              systemContent,
              msg.images || []
            );
            systemMessage += `
                        <div class="message ${roleClass}">
                          <strong>${
                            msg.role.charAt(0).toUpperCase() + msg.role.slice(1)
                          }:</strong>
                          <div class="chunk">${processedContent}</div>
                        </div>
                      `;
            console.groupEnd();
          }
        });
        console.groupEnd();

        // Process the last user message separately
        console.group("Processing last user message");
        if (lastMessageIndex !== -1) {
          const lastMsg = context[lastMessageIndex];
          const roleClass = lastMsg.role + "-message";
          const processedContent = processMessageContent(
            lastMsg.content || "",
            lastMsg.images || []
          );
          lastUserMessage = `
                      <div class="message ${roleClass}">
                        <strong>${
                          lastMsg.role.charAt(0).toUpperCase() +
                          lastMsg.role.slice(1)
                        }:</strong>
                        <div class="chunk">${processedContent}</div>
                      </div>
                    `;
        }
        console.groupEnd();

        const result = `
                    <div class="context-container">
                      <div class="context-toggle" onclick="toggleContext(this)">Show Context ◀</div>
                      <div class="context-content">
                        ${regularMessages}
                        ${
                          regularMessages && systemMessage
                            ? '<div class="source-separator"></div>'
                            : ""
                        }
                        ${systemMessage}
                        ${
                          (regularMessages || systemMessage) && lastUserMessage
                            ? '<div class="source-separator"></div>'
                            : ""
                        }
                        ${lastUserMessage}
                      </div>
                    </div>
                  `;

        console.log("Final HTML length:", result.length);
        console.groupEnd();
        return result;
      }

      // Modified appendMessage to add an edit icon for user messages
      function appendMessage(sender, content, context = null) {
        const role =
          sender.toLowerCase() === "user"
            ? "user"
            : sender.toLowerCase() === "system"
            ? "system"
            : sender.toLowerCase() === "tool"
            ? "tool"
            : "assistant";

        messageHistory.push({ role: role, content: content });

        const messageDiv = document.createElement("div");
        messageDiv.className = `message ${role}-message`;

        // For user messages, store the original content and history index.
        if (role === "user") {
          messageDiv.dataset.originalContent = content;
          messageDiv.dataset.msgIndex = messageHistory.length - 1;
        }

        const mainContent =
          sender === "User" ? md.utils.escapeHtml(content) : content;
        const rendered = md.render(mainContent);
        const contextSection =
          role === "assistant" ? createContextSection(context) : "";

        messageDiv.innerHTML = rendered + contextSection;

        // If this is a user message, append an edit icon.
        if (role === "user") {
          const editButton = document.createElement("div");
          editButton.className = "edit-icon";
          editButton.innerHTML = '<i class="fas fa-edit"></i>';
          editButton.addEventListener("click", function (e) {
            e.stopPropagation();
            editUserMessage(messageDiv);
          });
          messageDiv.appendChild(editButton);
        }

        chatContainer.appendChild(messageDiv);
        chatContainer.scrollTop = chatContainer.scrollHeight;
        window.scrollTo({
          top: document.body.scrollHeight,
          behavior: "smooth",
        });

        mermaid.init(undefined, document.querySelectorAll(".mermaid"));
      }

      // Modified sendQuery to handle stopping
      async function sendQuery(endpoint = "/chat", skipUserAppend = false) {
        const queryText = queryInput.value.trim();
        if (!queryText) return;
        if (isGenerating) return; // Prevent sending while generating

        // Reset any previous state and setup for new generation
        if (currentController) {
          currentController.abort();
        }
        currentController = new AbortController();
        isGenerating = true;

        // Update button visibility
        const stopButton = document.getElementById("stop-button");
        const sendButton = document.querySelector(".send-button");
        stopButton.style.display = "flex";
        sendButton.style.display = "none";

        if (!skipUserAppend) {
          appendMessage("User", queryText);
        }
        queryInput.value = "";
        resizeTextarea();

        // Start thinking animation immediately for /think endpoint
        // or create empty assistant message for /chat
        if (endpoint === "/think") {
          thinkingDiv = createThinkingProcessContainer();
          chatContainer.appendChild(thinkingDiv);
          thinkingContentDiv = thinkingDiv.querySelector(".thinking-content");
          thinkingStartTime = Date.now();
          const thinkingText = thinkingDiv.querySelector(".thinking-text");
          if (thinkingText) {
            thinkingText.classList.remove("static");
          }
          isThinkingActive = true;
        } else if (endpoint === "/chat") {
          createOrUpdateAssistantMessage("");
        }

        // Reset state variables
        assistantTextBuffer = "";
        contextSet = false;
        latestContext = null;
        let errorBuffer = [];

        const toolsActorsList = getActiveTools();

        if (toolsEnabled && toolsActorsList.length === 0) {
          alert("Please provide at least one tools actor.");
          toolsEnabled = false;
          updateToolButton();
          resetGenerationState();
          return;
        }

        // Get Active sources

        let activeSources = getActiveSources().map((source) => source.path);

        const queryObject = {
          messages: messageHistory,
          model: "llama3.2",
          stream: true,
          tools_actors: toolsEnabled
            ? toolsActorsList.map((tool) => tool.actor)
            : [],
          ...(activeSources.length > 0 && { sources: activeSources }),
        };

        try {
          const response = await fetch(`${RAG_ENDPOINT}${endpoint}`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(queryObject),
            signal: currentController.signal,
          });

          if (!response.ok) {
            errorBuffer.push(`HTTP error! status: ${response.status}`);
          }

          // Display error container at the start if we have errors
          let errorDiv = null;
          if (errorBuffer.length > 0) {
            errorDiv = document.createElement("div");
            errorDiv.className = "message error-message";
            const errorContent = `
                        <div class="error-toggle">▶</div>
                        <div class="error-header">⚠️ ${
                          errorBuffer.length
                        } Error${
              errorBuffer.length > 1 ? "s" : ""
            } Occurred</div>
                        <div class="error-content">
                          ${errorBuffer
                            .map(
                              (error) => `
                            <div class="error-item">
                              <i class="fas fa-exclamation-circle"></i>
                              ${md.render(error)}
                            </div>
                          `
                            )
                            .join("")}
                        </div>
                      `;
            errorDiv.innerHTML = errorContent;
            chatContainer.appendChild(errorDiv);
            initializeErrorToggles(errorDiv);
          }

          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let buffer = "";

          while (true) {
            const { value, done } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value);
            buffer += chunk;

            const lines = buffer.split("\n");
            buffer = lines.pop() || "";

            for (const line of lines) {
              if (!line.trim()) continue;
              try {
                processJsonLine(line);
              } catch (e) {
                console.error("Error processing JSON line:", e);
                console.error("Raw line content:", line);
                errorBuffer.push(`Error processing response: ${e.message}`);
                if (errorDiv) {
                  const errorContent = createErrorContent(errorBuffer);
                  errorDiv.innerHTML = errorContent;
                  initializeErrorToggles(errorDiv);
                } else {
                  errorDiv = createErrorDiv(errorBuffer);
                  chatContainer.appendChild(errorDiv);
                  initializeErrorToggles(errorDiv);
                }
              }
            }
          }

          // Handle any remaining text after streaming
          if (assistantTextBuffer) {
            createOrUpdateAssistantMessage(assistantTextBuffer, latestContext);
          }
        } catch (error) {
          if (error.name === "AbortError") {
            console.log("Request was aborted");
          } else {
            console.error("Error:", error);
            const errorDiv = document.createElement("div");
            errorDiv.className = "message error-message";
            const errorContent = `
                        <div class="error-toggle">▶</div>
                        <div class="error-header">⚠️ Error Occurred</div>
                        <div class="error-content">
                          <div class="error-item">
                            <i class="fas fa-exclamation-circle"></i>
                            ${md.render(error.toString())}
                          </div>
                        </div>
                      `;
            errorDiv.innerHTML = errorContent;
            chatContainer.appendChild(errorDiv);
            initializeErrorToggles(errorDiv);
          }
        } finally {
          resetGenerationState();
        }
      }

      // Helper function to create error content
      function createErrorContent(errorBuffer) {
        return `
                    <div class="error-toggle">▶</div>
                    <div class="error-header">⚠️ ${errorBuffer.length} Error${
          errorBuffer.length > 1 ? "s" : ""
        } Occurred</div>
                    <div class="error-content">
                      ${errorBuffer
                        .map(
                          (error) => `
                        <div class="error-item">
                          <i class="fas fa-exclamation-circle"></i>
                          ${md.render(error)}
                        </div>
                      `
                        )
                        .join("")}
                    </div>
                  `;
      }

      // Helper function to create error div
      function createErrorDiv(errorBuffer) {
        const errorDiv = document.createElement("div");
        errorDiv.className = "message error-message";
        errorDiv.innerHTML = createErrorContent(errorBuffer);
        return errorDiv;
      }

      // Add stop button event listener
      stopButton.addEventListener("click", stopGeneration);

      // Function to handle editing a user message.
      function editUserMessage(messageDiv) {
        const originalContent =
          messageDiv.dataset.originalContent || messageDiv.innerText;

        // Get container and message dimensions before clearing content
        const containerRect = chatContainer.getBoundingClientRect();
        const messageRect = messageDiv.getBoundingClientRect();
        const rightOffset = containerRect.right - messageRect.right;

        // Clear current message content
        messageDiv.innerHTML = "";
        messageDiv.style.marginRight = rightOffset + "px";
        messageDiv.style.width = containerRect.width - rightOffset + "px";

        // Create edit container
        const editContainer = document.createElement("div");
        editContainer.style.position = "relative";
        editContainer.style.width = "100%";
        editContainer.style.display = "block";
        editContainer.style.minHeight = "150px";

        const textarea = document.createElement("textarea");
        textarea.value = originalContent;
        textarea.style.width = "100%";
        textarea.style.height = "150px";
        textarea.style.boxSizing = "border-box";
        textarea.style.padding = "10px";
        textarea.style.border = "1px solid var(--border-color)";
        textarea.style.borderRadius = "5px";
        textarea.style.backgroundColor = "var(--bg-main)";
        textarea.style.color = "var(--text-primary)";
        textarea.style.marginBottom = "60px";

        editContainer.appendChild(textarea);

        const buttonContainer = document.createElement("div");
        buttonContainer.style.position = "absolute";
        buttonContainer.style.bottom = "10px";
        buttonContainer.style.right = "10px";
        buttonContainer.style.display = "flex";
        buttonContainer.style.gap = "5px";

        const cancelButton = document.createElement("button");
        cancelButton.textContent = "Cancel";
        cancelButton.className = "action-button";
        cancelButton.style.margin = "0";

        const saveButton = document.createElement("button");
        saveButton.textContent = "Send";
        saveButton.className = "action-button";
        saveButton.style.margin = "0";

        buttonContainer.appendChild(cancelButton);
        buttonContainer.appendChild(saveButton);
        editContainer.appendChild(buttonContainer);

        messageDiv.appendChild(editContainer);

        cancelButton.addEventListener("click", function () {
          messageDiv.innerHTML = md.render(
            md.utils.escapeHtml(originalContent)
          );
          messageDiv.dataset.originalContent = originalContent;
          messageDiv.style.marginRight = "";
          messageDiv.style.width = "";
          const editButton = document.createElement("div");
          editButton.className = "edit-icon";
          editButton.innerHTML = '<i class="fas fa-edit"></i>';
          editButton.addEventListener("click", function (e) {
            e.stopPropagation();
            editUserMessage(messageDiv);
          });
          messageDiv.appendChild(editButton);
        });

        saveButton.addEventListener("click", function () {
          // Stop any ongoing generation first
          stopGeneration();

          const newContent = textarea.value.trim();
          if (!newContent) return;
          const indexInChat = Array.from(chatContainer.children).indexOf(
            messageDiv
          );
          while (chatContainer.children.length > indexInChat + 1) {
            chatContainer.removeChild(chatContainer.lastChild);
          }
          const msgIndex = parseInt(messageDiv.dataset.msgIndex, 10);
          messageHistory = messageHistory.slice(0, msgIndex + 1);
          messageHistory[msgIndex].content = newContent;
          messageDiv.innerHTML = md.render(md.utils.escapeHtml(newContent));
          messageDiv.style.marginRight = "";
          messageDiv.style.width = "";
          messageDiv.dataset.originalContent = newContent;
          const editButton = document.createElement("div");
          editButton.className = "edit-icon";
          editButton.innerHTML = '<i class="fas fa-edit"></i>';
          editButton.addEventListener("click", function (e) {
            e.stopPropagation();
            editUserMessage(messageDiv);
          });
          messageDiv.appendChild(editButton);
          queryInput.value = newContent;
          sendQuery(thinkEnabled ? "/think" : "/chat", true);
        });
      }

      function processJsonLine(json_line) {
        const data = JSON.parse(json_line);

        if (data.error) {
          const errorDiv = document.createElement("div");
          errorDiv.className = "message error-message";
          const errorContent = `
                      <div class="error-toggle">▶</div>
                      <div class="error-header">⚠️ Error Occurred</div>
                      <div class="error-content">
                        <div class="error-item">
                          <i class="fas fa-exclamation-circle"></i>
                          ${md.render(data.error)}
                        </div>
                      </div>
                    `;
          errorDiv.innerHTML = errorContent;
          chatContainer.appendChild(errorDiv);
          initializeErrorToggles(errorDiv);
          return;
        }

        if (data.context) {
          latestContext = data.context;
        }

        if (!data.message?.content) {
          if (data.done) {
            if (assistantTextBuffer) {
              createOrUpdateAssistantMessage(
                assistantTextBuffer,
                latestContext
              );
              if (
                !messageHistory.some(
                  (msg) =>
                    msg.role === "assistant" &&
                    msg.content === assistantTextBuffer
                )
              ) {
                messageHistory.push({
                  role: "assistant",
                  content: assistantTextBuffer,
                  images: data.message?.images,
                });
              }
            }
          }
          return;
        }

        if (data.message.role === "system" || data.message.role === "tool") {
          handleSpecialRole(data.message);
          return;
        }

        if (data.message.role === "assistant") {
          let chunk = data.message.content;
          let idx = 0;

          while (idx < chunk.length) {
            if (!isThinkingActive) {
              const openPos = chunk.indexOf("<think>", idx);
              if (openPos === -1) {
                const visiblePart = chunk.substring(idx);
                assistantTextBuffer += visiblePart;
                idx = chunk.length;
              } else {
                const visiblePart = chunk.substring(idx, openPos);
                if (visiblePart.trim()) {
                  assistantTextBuffer += visiblePart;
                }
                idx = openPos + 7;
                if (!thinkingDiv) {
                  thinkingDiv = createThinkingProcessContainer();
                  chatContainer.appendChild(thinkingDiv);
                  thinkingContentDiv =
                    thinkingDiv.querySelector(".thinking-content");
                  thinkingStartTime = Date.now();
                  const thinkingText =
                    thinkingDiv.querySelector(".thinking-text");
                  if (thinkingText) {
                    thinkingText.classList.remove("static");
                  }
                }
                isThinkingActive = true;
              }
            } else {
              const closePos = chunk.indexOf("</think>", idx);
              if (closePos === -1) {
                const thoughtChunk = chunk.substring(idx);
                appendThinkingChunk(thoughtChunk, thinkingContentDiv);
                idx = chunk.length;
              } else {
                const thoughtChunk = chunk.substring(idx, closePos);
                if (thoughtChunk.trim()) {
                  appendThinkingChunk(thoughtChunk, thinkingContentDiv);
                }
                idx = closePos + 8;
                isThinkingActive = false;
                if (assistantTextBuffer.trim().length > 0) {
                  createOrUpdateAssistantMessage(
                    assistantTextBuffer,
                    latestContext
                  );
                }
                if (thinkingDiv && thinkingStartTime) {
                  const duration = (
                    (Date.now() - thinkingStartTime) /
                    1000
                  ).toFixed(1);
                  const thinkingText =
                    thinkingDiv.querySelector(".thinking-text");
                  if (thinkingText) {
                    thinkingText.textContent = `Thought for ${duration}s`;
                    thinkingText.classList.add("static");
                  }
                  thinkingStartTime = null;
                }
              }
            }
          }

          if (!isThinkingActive && assistantTextBuffer.length > 0) {
            createOrUpdateAssistantMessage(assistantTextBuffer, latestContext);
          }

          if (data.done) {
            const indicators = document.querySelectorAll(".typing-indicator");
            indicators.forEach((indicator) => indicator.remove());
            if (
              assistantTextBuffer &&
              !messageHistory.some(
                (msg) =>
                  msg.role === "assistant" &&
                  msg.content === assistantTextBuffer
              )
            ) {
              messageHistory.push({
                role: "assistant",
                content: assistantTextBuffer,
                images: data.message?.images,
              });
            }
            createOrUpdateAssistantMessage(assistantTextBuffer, latestContext);
            assistantTextBuffer = "";
          }
        }
      }

      function handleSpecialRole(msg) {
        const lastMessageDiv = chatContainer.lastElementChild;
        const lastMessageRole =
          lastMessageDiv?.className.match(/(\w+)-message/)?.[1];

        if (msg.role === "tool") {
          if (lastMessageRole === "assistant") {
            const assistantContent = lastMessageDiv.querySelector(
              "div:not(.context-container):not(.thinking-process)"
            );
            if (assistantContent && !assistantContent.textContent.trim()) {
              lastMessageDiv.remove();
            }
          }
          const toolData = JSON.parse(msg.content);
          const specialMessageDiv = document.createElement("div");
          specialMessageDiv.className = "message tool-message";
          const formattedContent = `
                      <div class="tool-toggle">▶</div>
                      <div class="tool-header">🔧 Tool Call: ${
                        toolData.tool
                      }</div>
                      <div class="tool-content">
                        <div class="tool-details">
                          <strong>Arguments:</strong>
                          <pre><code>${JSON.stringify(
                            toolData.call.function.arguments,
                            null,
                            2
                          )}</code></pre>
                          <strong>Response:</strong>
                          <pre><code>${JSON.stringify(
                            toolData.response,
                            null,
                            2
                          )}</code></pre>
                        </div>
                      </div>
                    `;
          specialMessageDiv.innerHTML = formattedContent;
          chatContainer.appendChild(specialMessageDiv);
          initializeToolToggles(specialMessageDiv);
        } else {
          if (lastMessageDiv && lastMessageRole === "system") {
            lastMessageDiv.innerHTML +=
              '<div class="source-separator"></div>' + md.render(msg.content);
          } else {
            const systemDiv = document.createElement("div");
            systemDiv.className = "message system-message";
            systemDiv.innerHTML = md.render(msg.content);
            chatContainer.appendChild(systemDiv);
          }
        }
      }

      function createOrUpdateAssistantMessage(visibleText, context = null) {
        const lastMessageDiv = chatContainer.lastElementChild;
        const lastMessageRole =
          lastMessageDiv?.className.match(/(\w+)-message/)?.[1];

        let assistantBlock;
        let assistantContent;

        if (lastMessageRole === "assistant") {
          assistantBlock = lastMessageDiv;
          assistantContent = assistantBlock.querySelector(
            "div:not(.context-container):not(.thinking-process)"
          );
          if (!assistantContent) {
            assistantContent = document.createElement("div");
            assistantBlock.appendChild(assistantContent);
          }
        } else {
          assistantBlock = document.createElement("div");
          assistantBlock.className = "message assistant-message";
          assistantContent = document.createElement("div");
          assistantBlock.appendChild(assistantContent);
          chatContainer.appendChild(assistantBlock);
        }

        const existingIndicators =
          assistantContent.querySelectorAll(".typing-indicator");
        existingIndicators.forEach((indicator) => indicator.remove());

        assistantContent.innerHTML = md.render(visibleText || "");
        const typingIndicator = document.createElement("span");
        typingIndicator.className = "typing-indicator";

        let lastContentElement = assistantContent;
        const walker = document.createTreeWalker(
          assistantContent,
          NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT,
          {
            acceptNode: function (node) {
              if (
                node.nodeType === Node.TEXT_NODE &&
                !node.textContent.trim()
              ) {
                return NodeFilter.FILTER_SKIP;
              }
              if (node.classList?.contains("typing-indicator")) {
                return NodeFilter.FILTER_SKIP;
              }
              return NodeFilter.FILTER_ACCEPT;
            },
          }
        );

        while (walker.nextNode()) {
          lastContentElement = walker.currentNode;
        }

        if (
          lastContentElement.nodeType === Node.TEXT_NODE ||
          getComputedStyle(lastContentElement).display === "inline"
        ) {
          lastContentElement.parentNode.appendChild(typingIndicator);
        } else {
          lastContentElement.appendChild(typingIndicator);
        }

        if (!contextSet && context?.length) {
          const contextSection = createContextSection(context);
          if (contextSection) {
            const contextDiv = document.createElement("div");
            contextDiv.innerHTML = contextSection;
            assistantBlock.appendChild(contextDiv);
          }
          contextSet = true;
        }

        chatContainer.scrollTop = chatContainer.scrollHeight;
      }

      function createThinkingProcessContainer() {
        const div = document.createElement("div");
        div.className = "thinking-process";
        div.innerHTML = `
                    <div class="thinking-header" onclick="toggleThinking(this)">
                      <span class="thinking-text">Thinking...</span>
                    </div>
                    <div class="thinking-content"></div>
                  `;
        return div;
      }

      function appendThinkingChunk(text, contentDiv) {
        if (!contentDiv) return;
        const cleanedText = text.replace(/<\/?think>/g, "");
        contentDiv.textContent += cleanedText;
      }

      window.toggleContext = function (toggleElement) {
        const contextContent = toggleElement.nextElementSibling;
        const isHidden =
          contextContent.style.display === "none" ||
          !contextContent.style.display;
        contextContent.style.display = isHidden ? "block" : "none";
        toggleElement.textContent = isHidden
          ? "Hide Context ▼"
          : "Show Context ◀";
      };

      window.toggleThinking = function (header) {
        const content = header.nextElementSibling;
        content.classList.toggle("visible");
      };

      function initializeToolToggles(container) {
        container.querySelectorAll(".tool-toggle").forEach((toggle) => {
          if (!toggle.hasListener) {
            toggle.addEventListener("click", function () {
              const content = this.parentElement.querySelector(".tool-content");
              const isHidden =
                content.style.display === "none" || !content.style.display;
              content.style.display = isHidden ? "block" : "none";
              this.textContent = isHidden ? "▼" : "▶";
            });
            toggle.hasListener = true;
          }
        });
      }

      function resizeTextarea() {
        queryInput.style.height = "auto";
        queryInput.style.height = queryInput.scrollHeight + "px";
      }

      queryInput.addEventListener("input", resizeTextarea);

      queryInput.addEventListener("keydown", async (e) => {
        if (e.key === "Enter") {
          if (e.shiftKey) {
            resizeTextarea();
            return;
          }
          if (isGenerating) {
            // Prevent sending while generating
            e.preventDefault();
            return;
          }
          if (e.ctrlKey) {
            e.preventDefault();

            const toolsActorsList = getActiveTools();

            // Only toggle if we have tools
            if (toolsActorsList.length > 0) {
              toolsEnabled = !toolsEnabled;
              updateToolButton();
            }
            return;
          }
          if (e.altKey) {
            e.preventDefault();
            thinkEnabled = !thinkEnabled;
            updateThinkButton();
            return;
          }
          e.preventDefault();
          const endpoint = thinkEnabled ? "/think" : "/chat";
          await sendQuery(endpoint);
        } else if (e.key === "Escape") {
          // Add Escape key handler
          if (isGenerating) {
            stopGeneration();
          }
        }
      });

      document
        .getElementById("send-button")
        .addEventListener("click", async () => {
          const toolsActorsList = getActiveTools();

          // Only toggle if we have tools
          if (toolsActorsList.length > 0) {
            toolsEnabled = !toolsEnabled;
            updateToolButton();
          }
        });

      document.getElementById("think-button").addEventListener("click", () => {
        // Allow toggling think mode even during generation
        thinkEnabled = !thinkEnabled;
        updateThinkButton();
      });

      function updateToolButton() {
        const toolButton = document.getElementById("send-button");

        const toolsActorsList = getActiveTools();

        // Disable tools if no actors are available
        if (toolsActorsList.length === 0) {
          toolsEnabled = false;
          toolButton.classList.remove("active");
          toolButton.style.opacity = "0.5";
          toolButton.style.cursor = "not-allowed";
          toolButton.title =
            "Please add at least one tool in the sidebar to enable tools";
        } else {
          toolButton.style.opacity = "1";
          toolButton.style.cursor = "pointer";
          toolButton.classList.toggle("active", toolsEnabled);
          toolButton.title = toolsEnabled ? "Tools enabled" : "Tools disabled";
        }

        localStorage.setItem("toolsEnabled", toolsEnabled);
      }

      function updateThinkButton() {
        const thinkButton = document.getElementById("think-button");
        thinkButton.classList.toggle("active", thinkEnabled);
        thinkButton.title = thinkEnabled
          ? "Think mode enabled"
          : "Think mode disabled";
        localStorage.setItem("thinkEnabled", thinkEnabled);
      }

      // Initialize sidebar state
      function initializeSidebar() {
        const sidebar = document.getElementById("sidebar");
        const mainContent = document.getElementById("main-content");
        const inputContainer = document.getElementById("input-container");

        if (sidebarVisible) {
          sidebar.classList.remove("collapsed");
          mainContent.classList.remove("sidebar-collapsed");
          inputContainer.classList.remove("sidebar-collapsed");
        } else {
          sidebar.classList.add("collapsed");
          mainContent.classList.add("sidebar-collapsed");
          inputContainer.classList.add("sidebar-collapsed");
        }

        // Initialize management
        initializeManagement();
      }

      // Management
      function initializeManagement() {
        // Tools

        const saveToolBtn = document.getElementById("save-tool-btn");
        const toolActorInput = document.getElementById("tool-actor");
        const deleteAllToolsBtn = document.getElementById("delete-all-tools");

        //Sources

        const saveSourceBtn = document.getElementById("save-source-btn");
        const deleteAllSourcesBtn =
          document.getElementById("delete-all-sources");

        // Add keypress event listener for Enter key
        toolActorInput.addEventListener("keypress", function (e) {
          if (e.key === "Enter") {
            e.preventDefault(); // Prevent form submission
            saveTool();
          }
        });

        deleteAllToolsBtn.addEventListener("click", function (e) {
          deleteAllTools();
          loadSavedTools();
          updateToolsActors();
        });

        deleteAllSourcesBtn.addEventListener("click", function (e) {
          deleteAllSources();
          loadSavedSources();
        });

        // Load saved tools from localStorage
        loadSavedTools();

        // Event Listeners
        saveToolBtn.addEventListener("click", saveTool);
      }

      // Clear based on id of the input
      function clearForm(input) {
        document.getElementById(input).value = "";
      }

      function saveTool() {
        const actor = document.getElementById("tool-actor").value.trim();

        if (!actor) {
          alert("Actor name is required!");
          return;
        }

        const savedTools = getSavedTools();

        if (
          savedTools.some(
            (tool) => tool.actor.toLowerCase() === actor.toLowerCase()
          )
        ) {
          alert("This tool already exists!");
          return;
        }

        const tool = {
          id: Date.now().toString(),
          actor,
          active: false,
        };

        // Save to localStorage
        savedTools.push(tool);
        localStorage.setItem("savedTools", JSON.stringify(savedTools));

        loadSavedTools();

        // Clear the form input
        clearForm("tool-actor");
      }

      function getSavedTools() {
        const tools = localStorage.getItem("savedTools");
        return tools ? JSON.parse(tools) : [];
      }

      function getSavedSources() {
        const sources = localStorage.getItem("savedSources");

        if (!sources) {
          return [];
        }

        const parsed_json = JSON.parse(sources);

        return parsed_json.sources;
      }

      function getLocalOnlySources() {
        const localSources = localStorage.getItem("localSources");

        if (!localSources) {
          return [];
        }

        return JSON.parse(localSources);
      }

      function getSavedSourcesExpanded() {
        const source = localStorage.getItem("savedSources");

        const parsed_json = JSON.parse(source);

        return parsed_json;
      }

      function getActiveTools() {
        const tools = localStorage.getItem("savedTools");

        let savedTools = JSON.parse(tools);

        return savedTools
          ? savedTools.filter((tool) => tool.active == true)
          : [];
      }

      function getActiveSources() {
        const sources = localStorage.getItem("savedSources");

        let savedSources = JSON.parse(sources);

        return savedSources.sources.filter((source) => source.active == true);
      }

      function loadSavedTools() {
        const savedToolsList = document.getElementById("saved-tools-list");
        savedToolsList.innerHTML = "";
        const savedTools = getSavedTools();

        savedTools.forEach((tool) => addToolToSavedList(tool));
      }

      function loadSavedSources() {
        const savedSourcesList = document.getElementById("saved-sources-list");
        savedSourcesList.innerHTML = "";
        const savedSources = getSavedSources();
        const localOnlySources = getLocalOnlySources();

        const allSources = [...savedSources, ...localOnlySources];

        allSources.forEach((source) => addSourceToSavedList(source));
      }

      async function fetchAvailableSources() {
        let endpoint = `${RAG_ENDPOINT}/sources`;

        const response = await fetch(endpoint, {
          method: "GET",
          headers: { "Content-Type": "application/json" },
        });

        let body = await response.json();

        let saved = getSavedSources();

        let maped_sources = body.sources.map((source_element) => {
          let split_path = source_element.source.split("/");

          const source = {
            id: Date.now().toString() + "-" + split_path[split_path.length - 1],
            path: source_element.source,
            display_name: split_path[split_path.length - 1],
            active: false,
          };

          return source;
        });

        const grouped = Object.groupBy(maped_sources, (item) => item.path);

        let keys = Object.keys(grouped).map((sourceLabel) => {
          let exist = saved.find((element) => element.path == sourceLabel);

          if (exist) {
            return exist;
          } else {
            return {
              active: false,
              path: sourceLabel,
            };
          }
        });

        // let localSources = getLocalOnlySources();

        localStorage.setItem(
          "savedSources",
          JSON.stringify({
            sources: [...keys],
            sourcesExpanded: maped_sources,
          })
        );

        loadSavedSources();

        return body.sources;
      }

      function createToolElement(tool, isActive = false) {
        const toolElement = document.createElement("div");
        toolElement.className = `tool-item`;
        toolElement.dataset.toolId = tool.id;
        toolElement.dataset.tooltip = tool.actor; // Add tooltip text
        toolElement.innerHTML = `
                <div class="tool-item-header">
                  <span class="tool-icon"><i class="fas fa-wrench"></i></span>
                  <span class="tool-item-name">${tool.actor}</span>
                  <label class="switch">
                      <input type="checkbox" class="tool-toggle" ${
                        isActive ? "checked" : ""
                      }>
                      <span class="slider"></span>
                  </label>
                  <div class="tool-actions">
                      <button class="tool-action-btn delete-tool" title="Delete">
                        <i class="fas fa-trash"></i>
                      </button>
                  </div>
                </div>
              `;

        // Add event listeners
        const actions = toolElement.querySelector(".tool-actions");

        toolElement
          .querySelector(".tool-toggle")
          .addEventListener("change", (e) => {
            e.stopPropagation();
            setToolState(tool, e.target.checked);
            updateToolsActors();
          });

        actions.querySelector(".delete-tool").addEventListener("click", (e) => {
          e.stopPropagation(); // Prevent triggering the parent click
          deleteTool(tool);
          updateToolsActors();
        });

        return toolElement;
      }

      function createSourceElement(source, isActive = false) {
        const sourceElement = document.createElement("div");
        sourceElement.className = `source-item`;
        sourceElement.dataset.sourceId = source.id;
        sourceElement.dataset.tooltip = source.path;
        sourceElement.innerHTML = `
        <div class="source-item-header">
            <span class="source-icon"><i class="fa-solid fa-book"></i></span>
            <span class="source-item-name">${source.path}</span>
            ${
              source.isLocal
                ? ""
                : `<label class="switch">
                    <input type="checkbox" class="source-toggle" ${
                      isActive ? "checked" : ""
                    }>
                    <span class="slider"></span>
                </label>`
            }
            <span id="upload-button" class="upload-icon upload-button" title="Upload file to source">
                <i class="fa-solid fa-paperclip"></i>
                <input type="file" id="file-input" class="file-input" style="display: none" />
            </span>
            <span class="upload-status" style="display: none; font-size: 12px; margin-left: 10px;"></span>
            <div class="source-actions">
                <button class="source-action-btn delete-source" title="Delete">
                    <i class="fas fa-trash"></i>
                </button>
            </div>
        </div>
    `;

        if (!source.isLocal) {
          sourceElement
            .querySelector(".source-toggle")
            .addEventListener("change", (e) => {
              e.stopPropagation();
              setSourceState(source, e.target.checked);
            });
        }

        sourceElement
          .querySelector(".delete-source")
          .addEventListener("click", async (e) => {
            e.stopPropagation();
            if (source.isLocal) {
              deleteFromLocalSources(source);
            } else {
              let uploadButton = sourceElement.querySelector(".upload-button");
              let uploadStatus = sourceElement.querySelector(".upload-status");
              let switchElement = sourceElement.querySelector(".switch");

              uploadButton.style.pointerEvents = "none";
              uploadButton.style.display = "none";
              uploadStatus.style.display = "inline";
              uploadStatus.innerText = "Deleting...";

              if (switchElement) {
                switchElement.style.display = "none";
              }

              try {
                await deleteSources([source.path]);
                uploadStatus.innerText = "Delete Complete!";
              } catch (error) {
                uploadStatus.innerText = "Delete Failed!";
              } finally {
                setTimeout(() => {
                  uploadButton.style.display = "block";
                  uploadButton.style.pointerEvents = "auto";

                  if (switchElement) {
                    switchElement.style.display = "block";
                  }
                }, 2000);
              }
            }
          });

        sourceElement
          .querySelector(".upload-button")
          .addEventListener("click", function () {
            sourceElement.querySelector(".file-input").click();
          });

        sourceElement
          .querySelector(".file-input")
          .addEventListener("change", async function (event) {
            const file = event.target.files[0];

            let uploadButton = sourceElement.querySelector(".upload-button");
            let uploadStatus = sourceElement.querySelector(".upload-status");
            let switchElement = sourceElement.querySelector(".switch");

            uploadButton.style.pointerEvents = "none";
            uploadButton.style.display = "none";
            uploadStatus.style.display = "inline";
            uploadStatus.innerText = "Processing...";

            if (switchElement) {
              switchElement.style.display = "none";
            }

            try {
              await uploadAndIndexSource(file, source);
              uploadStatus.innerText = "Upload Complete!";
            } catch (error) {
              uploadStatus.innerText = "Upload Failed!";
            } finally {
              setTimeout(() => {
                uploadButton.style.display = "block";
                uploadButton.style.pointerEvents = "auto";

                if (switchElement) {
                  switchElement.style.display = "block";
                }
              }, 2000);
            }
          });

        return sourceElement;
      }

      function addNewSource() {
        let sourceValue = document.getElementById("source").value;

        if (!sourceValue) {
          alert("Please type a valid source.");
          return;
        }

        if (sourceValue[0] != "/") {
          sourceValue = `/${sourceValue}`;
        }

        const savedSources = getSavedSources();
        const localOnlySources = getLocalOnlySources();

        const allSources = [...savedSources, ...localOnlySources];

        if (allSources.some((element) => element.path == sourceValue)) {
          alert("Source already exists.");
          return;
        }

        const source = {
          path: sourceValue,
          active: false,
          isLocal: true,
        };

        localOnlySources.push(source);

        localStorage.setItem("localSources", JSON.stringify(localOnlySources));

        document.getElementById("source").value = "";

        loadSavedSources();
      }

      function addToolToSavedList(tool) {
        const savedToolsList = document.getElementById("saved-tools-list");
        const toolElement = createToolElement(tool, tool.active);
        savedToolsList.appendChild(toolElement);
      }

      function addSourceToSavedList(source) {
        const savedSourcesList = document.getElementById("saved-sources-list");
        const sourceElement = createSourceElement(source, source.active);
        savedSourcesList.appendChild(sourceElement);
      }

      function setSourceState(activeSource, state) {
        let savedSourcesExpanded = getSavedSourcesExpanded();

        let sources = savedSourcesExpanded.sources;

        savedSourcesExpanded.sources = savedSourcesExpanded.sources.map(
          (source) =>
            source.path == activeSource.path
              ? { ...source, active: state }
              : source
        );

        localStorage.setItem(
          "savedSources",
          JSON.stringify(savedSourcesExpanded)
        );
      }

      function setToolState(activeTool, state) {
        let savedTools = getSavedTools();

        savedTools = savedTools.map((tool) =>
          tool.id == activeTool.id ? { ...tool, active: state } : tool
        );

        localStorage.setItem("savedTools", JSON.stringify(savedTools));
      }

      function deleteTool(tool) {
        const savedTools = getSavedTools().filter((t) => t.id !== tool.id);
        localStorage.setItem("savedTools", JSON.stringify(savedTools));

        loadSavedTools();
        updateToolsActors();
        updateToolButton();
      }

      function deleteAllTools() {
        localStorage.removeItem("savedTools");
      }

      async function deleteSources(sources) {
        const deleteResponse = await fetch(`${RAG_ENDPOINT}/delete_source`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            sources: sources,
          }),
        });

        await fetchAvailableSources();

        loadSavedSources();
        updateSources();
      }

      function deleteFromLocalSources(source) {
        const localSources = getLocalOnlySources();

        localStorage.setItem(
          "localSources",
          JSON.stringify(
            localSources.filter((element) => element.path != source.path)
          )
        );

        loadSavedSources();
      }

      async function deleteAllSources() {
        let savedSources = getSavedSources().map((source) => source.path);

        await deleteSources(savedSources);

        localStorage.removeItem("savedSources");
        localStorage.removeItem("localSources");
      }

      function updateToolsActors() {
        const activeTools = getActiveTools();

        // Update tools state based on actors
        if (activeTools.length === 0) {
          toolsEnabled = false;
        }
        updateToolButton();
      }

      function updateSources() {
        const activeSources = getActiveSources();
        const paths = activeSources.map((source) => source.path);

        const sourcesInput = document.getElementById("sources-input");
        sourcesInput.value = paths.join(", ");

        localStorage.setItem("sources", paths.join(", "));

        // Update sources state based on paths
        if (paths.length === 0) {
          sourcesEnabled = false;
        }
      }

      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const mainContent = document.getElementById("main-content");
        const inputContainer = document.getElementById("input-container");
        const resizer = document.getElementById("resizer");

        sidebar.style.width = "";

        sidebarVisible = !sidebarVisible;
        localStorage.setItem("sidebarVisible", sidebarVisible);

        sidebar.classList.toggle("collapsed");
        mainContent.classList.toggle("sidebar-collapsed");
        inputContainer.classList.toggle("sidebar-collapsed");

        chatContainer.scrollTop = chatContainer.scrollHeight;
      }

      // Add event listener for sidebar toggle
      document
        .getElementById("sidebar-toggle")
        .addEventListener("click", toggleSidebar);

      // Initialize sidebar on page load
      document.addEventListener("DOMContentLoaded", () => {
        initializeSidebar();

        // Initialize send button functionality
        const sendButton = document.querySelector(".send-button");
        sendButton.addEventListener("click", async () => {
          if (!isGenerating) {
            const endpoint = thinkEnabled ? "/think" : "/chat";
            await sendQuery(endpoint);
          }
        });

        // Load stored tools state
        const storedToolsEnabled = localStorage.getItem("toolsEnabled");

        // Load stored sources state
        const sourcesInput = document.getElementById("sources-input");
        const storedSources = localStorage.getItem("sources");

        if (storedSources) {
          sourcesInput.value = storedSources;
        }

        // Then set the tools state
        if (storedToolsEnabled !== null) {
          toolsEnabled = storedToolsEnabled === "true";

          const toolsActorsList = getActiveTools();

          if (toolsActorsList.length === 0) {
            toolsEnabled = false;
          }
        }

        updateToolButton();
        updateThinkButton();

        // Add click handler for input container
        const inputContainer = document.getElementById("input-container");
        const queryInput = document.getElementById("query-input");

        inputContainer.addEventListener("click", (e) => {
          // Always focus the input, but let button clicks still work
          queryInput.focus();
          // Place cursor at the end of the text
          const len = queryInput.value.length;
          queryInput.setSelectionRange(len, len);

          // Don't prevent default for buttons so they still work
          if (e.target.closest("button")) {
            e.stopPropagation();
          }
        });

        // Remove the utilities container click handler since we want clicks there to work
        // ... existing code ...
      });

      // Initialize styles for disabled button state
      (function () {
        const style = document.createElement("style");
        style.textContent = `
                    .action-button[style*="cursor: not-allowed"]:hover {
                      background: var(--bg-secondary) !important;
                      border-color: var(--border-color) !important;
                    }
                  `;
        document.head.appendChild(style);
      })();

      function initializeErrorToggles(container) {
        container.querySelectorAll(".error-toggle").forEach((toggle) => {
          if (!toggle.hasListener) {
            toggle.addEventListener("click", function () {
              const content =
                this.parentElement.querySelector(".error-content");
              const isHidden =
                content.style.display === "none" || !content.style.display;
              content.style.display = isHidden ? "block" : "none";
              this.textContent = isHidden ? "▼" : "▶";
            });
            toggle.hasListener = true;
          }
        });
      }

      // Add stop generation functionality
      function stopGeneration() {
        if (currentController) {
          currentController.abort();
          currentController = null;
        }
        resetGenerationState();
      }

      function resetGenerationState() {
        isGenerating = false;
        const stopButton = document.getElementById("stop-button");
        const sendButton = document.querySelector(".send-button");
        stopButton.style.display = "none";
        sendButton.style.display = "flex";

        // Check input content to set correct button state
        sendButton.disabled = !queryInput.value.trim();

        // Reset thinking state if active
        if (isThinkingActive) {
          isThinkingActive = false;
          if (thinkingDiv) {
            const thinkingText = thinkingDiv.querySelector(".thinking-text");
            if (thinkingText) {
              const duration = (
                (Date.now() - thinkingStartTime) /
                1000
              ).toFixed(1);
              thinkingText.textContent = `Thought stopped after ${duration}s`;
              thinkingText.classList.add("static");
            }
          }
          thinkingStartTime = null;
        }

        // If we have a partial assistant message, finalize it
        if (assistantTextBuffer) {
          createOrUpdateAssistantMessage(assistantTextBuffer, latestContext);
          if (
            !messageHistory.some(
              (msg) =>
                msg.role === "assistant" && msg.content === assistantTextBuffer
            )
          ) {
            messageHistory.push({
              role: "assistant",
              content: assistantTextBuffer,
            });
          }
          assistantTextBuffer = "";
        }

        const indicators = document.querySelectorAll(".typing-indicator");
        indicators.forEach((indicator) => indicator.remove());

        // Re-enable input
        queryInput.disabled = false;
        queryInput.focus();
      }

      // Add input validation for send button
      queryInput.addEventListener("input", function () {
        const sendButton = document.querySelector(".send-button");
        sendButton.disabled = !this.value.trim();
        resizeTextarea();
      });
    </script>
  </body>
</html>
